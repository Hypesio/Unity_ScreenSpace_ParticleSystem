// Here we will handle the particles 
// Their position, collisions, etc...
#define WARP_SIZE 256

#pragma kernel CSSetIndirectArgs
#pragma kernel CSParticlesSimulation
#pragma kernel CSBufferUnion
#pragma kernel CSClearIndirectDrawArgs

#include "ParticlesCommons.cginc"
#include "SSFXUtils.cginc"

// 0 - VertexCount
// 1 - InstanceCount 
// 2 - StartVertexCount 
// 3 - StartInstanceLocation 
// 4 - PreviousInstanceCount
// 5 - FrameNumber
// 6 - Index if buffer full
uniform RWBuffer<int> _ParticlesDrawArgs;
#define _ParticlesCounter _ParticlesDrawArgs[1]

uniform RWStructuredBuffer<ParticleDatas> _ParticlesDatasBuffer;
uniform StructuredBuffer<ParticleDatas> _PreviousParticlesDatasBuffer;
uniform StructuredBuffer<ParticlesConfig> _ParticlesConfigs;
uniform int _MaxParticlesCount;
uniform int _PrioritizeNewParticles;

// Move variables
// x = Gravity, y = _FloorHeight, z = MaxSpeed, w = ?
uniform float4 _SimulationBase;
// xyz = Wind Direction
uniform float4 _Wind;
uniform Texture2D<float3> _NoiseMap;
SamplerState sampler_NoiseMap;
// XY = Tilling, Z = Strength, W = ?
uniform float4 _NoiseMap_ST;
uniform float4 _TargetPosition;
// XYZ = Position, W = TargetAttractionForce
uniform float4 _ParticlesTarget;

uniform RWBuffer<int> _IndirectArgs; // buffer union args, simulation args

#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)

/** 
Set the threads value for dispatch indirect
**/
[numthreads(1,1,1)]
void CSSetIndirectArgs (uint3 id : SV_DispatchThreadID)
{
    int argsUnion = ceil(float(_ParticlesDrawArgs[4]) / WARP_SIZE);
    _IndirectArgs[0] = argsUnion;
    
    float maxParticlesToSimulate = min(_ParticlesCounter + _ParticlesDrawArgs[4], _MaxParticlesCount);
    int argsSimulation = ceil(maxParticlesToSimulate / WARP_SIZE);
    _IndirectArgs[3] = argsSimulation;
}

[numthreads(1,1,1)]
void CSClearIndirectDrawArgs (uint3 id : SV_DispatchThreadID)
{
    // Set the previous counter with actual buffer size
    _ParticlesDrawArgs[4] = _ParticlesDrawArgs[1];
    _ParticlesDrawArgs[1] = 0;
}

/**
Here we handle the movements of the particles
**/
[numthreads(WARP_SIZE,1,1)]
void CSParticlesSimulation (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x;
    if (particleIndex > _ParticlesCounter)
        return;
    
    ParticleDatas datas = _ParticlesDatasBuffer[particleIndex]; 
    ParticlesConfig config = _ParticlesConfigs[datas.indexConfig];

    if (config.flagsFeature & FLAG_KILL_ALL)
    {
        datas.duration = -1;
        _ParticlesDatasBuffer[particleIndex] = datas;
        return;
    }
    
    float timeLived = _Time_SSFX.x - datas.timeApparition;
    float lifeProgress = timeLived / datas.duration;

    if (config.flagsFeature & FLAG_SIZE_OVER_LIFETIME)
        datas.size = datas.startSize * GetCurveValue(config.grad_sizeOverLifetime, lifeProgress);

    if (config.flagsFeature & FLAG_COLOR_OVER_LIFETIME)
    {
        if (config.flagsFeature & FLAG_ALPHA_OVER_LIFETIME)
        {
            float lerpProgress = GetCurveValue(config.grad_alphaOverLifetime, lifeProgress);
            float3 color = GetCurveColor(config.grad_colorOverLifetime, lifeProgress);
            datas.color.rgb = lerp(datas.startColor, color, lerpProgress);
        }
        else 
            datas.color.rgb = GetCurveColor(config.grad_colorOverLifetime, lifeProgress);
    }

    //if (config.flagsFeature & FLAG_ALPHA_OVER_LIFETIME)



    float2 uv = datas.worldPosition.xy * _NoiseMap_ST.xy;
    
    // Size over lifetime
    if (config.flagsFeature & FLAG_SPEED_OVER_LIFETIME)
        datas.speed = normalize(datas.speed) * datas.startSpeed * GetCurveValue(config.grad_speedOverLifetime, lifeProgress);

    float lenSpeed = length(datas.speed);

    // Move to target
    if (config.flagsFeature & FLAG_TARGET)
    {
        float3 directionToTarget = config.targetDatas.xyz - datas.worldPosition.xyz;
        float particleDistToTarget = length(directionToTarget);
        float targetAttraction;
        float targetDeathRadius;
        Unpack2Float32(config.targetDatas.w, 100.0f, 20.0f, targetAttraction, targetDeathRadius);
        if (config.flagsFeature & FLAG_TARGET_DIE_ON_REACH && particleDistToTarget < targetDeathRadius)//lenSpeed * _Time_SSFX.y)
            datas.duration = -1;

        float3 speedToTarget = normalize(directionToTarget) * lenSpeed;
        datas.speed = normalize(lerp(datas.speed, speedToTarget, targetAttraction * _Time_SSFX.y)) * lenSpeed;
        
        //if (lenSpeed > particleDistToTarget)
        //    datas.speed = normalize(datas.speed) * particleDistToTarget;
    }



    //float3 flowSpeed = (_NoiseMap.SampleLevel(sampler_NoiseMap, uv, 0.0).xyz - 1.0) * 2.0;
    //float3 newSpeed = (float3(0, _SimulationBase.x, 0) + flowSpeed * _NoiseMap_ST.z + normalize(_Wind.xyz) * _Wind.w) * _Time_SSFX.y;
    
    

    /*newSpeed += directionToTarget * distanceInfluenceTargetAttraction * _Time_SSFX.y;
    if (length(newSpeed) > _SimulationBase.z)
        newSpeed = normalize(newSpeed) * _SimulationBase.z;
    datas.speed = lerp(datas.speed, newSpeed, 0.2);
    if (length(datas.speed) > _SimulationBase.z)
        datas.speed = normalize(datas.speed) * _SimulationBase.z;*/
    datas.worldPosition += float4(datas.speed * _Time_SSFX.y, 0);
    //datas.worldPosition.y = max(datas.worldPosition.y, _SimulationBase.y);

//    else 
//        datas.worldPosition += float4(datas.normal * 0.01, 0.0f);
    _ParticlesDatasBuffer[particleIndex] = datas;
}

/**
The goal here is to add the previous still alive particles
to the buffer of new particles
**/
[numthreads(WARP_SIZE,1,1)]
void CSBufferUnion (uint id : SV_DispatchThreadID)
{
    int bufferIndex = id.x;
    int previousBufferSize = _ParticlesDrawArgs[4];

    if (bufferIndex > previousBufferSize)
        return;
    
    if (!_PrioritizeNewParticles)
        bufferIndex = previousBufferSize - id.x;
    
    if (_ParticlesCounter >= _MaxParticlesCount)
        return;

    ParticleDatas particle = _PreviousParticlesDatasBuffer[bufferIndex];
    float timeLived = _Time_SSFX.x - particle.timeApparition;
    if (timeLived < particle.duration && particle.duration > 0) 
    {
        // Check if the particle is still alive
        int indexNewBuffer;
        InterlockedAdd(_ParticlesCounter, 1, indexNewBuffer);
        if (indexNewBuffer >= _MaxParticlesCount)
        {
            if (_PrioritizeNewParticles)
                return;
            else 
            {
                // Replace new particles by older at the beginning of the buffer
                // _ParticlesDrawArgs[6] is the index to use if buffer is full
                InterlockedAdd(_ParticlesDrawArgs[6], 1, indexNewBuffer);
            }
        }
        _ParticlesDatasBuffer[indexNewBuffer] = particle;
    }
}