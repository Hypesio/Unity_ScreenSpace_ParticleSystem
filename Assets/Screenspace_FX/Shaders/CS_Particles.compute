// Here we will handle the particles 
// Their position, collisions, etc...
#define WARP_SIZE 256

#pragma kernel CSSetIndirectArgs
#pragma kernel CSParticlesSimulation
#pragma kernel CSBufferUnion
#pragma kernel CSClearIndirectDrawArgs

#include "ParticlesCommons.cginc"
#include "SSFXUtils.cginc"

// 0 - VertexCount
// 1 - InstanceCount 
// 2 - StartVertexCount a
// 3 - StartInstanceLocation 
// 4 - PreviousInstanceCount
// 5 - FrameNumber
// 6 - Index if buffer full
uniform RWBuffer<int> _ParticlesDrawArgs;
#define _ParticlesCounter _ParticlesDrawArgs[1]

uniform RWStructuredBuffer<ParticleDatas> _ParticlesDatasBuffer;
uniform StructuredBuffer<ParticleDatas> _PreviousParticlesDatasBuffer;
uniform StructuredBuffer<ParticlesConfig> _ParticlesConfigs;
uniform Buffer<float4> _SplinesPositions;
uniform StructuredBuffer<SplineInfos> _SplinesInfos;
uniform int _SplineCount;
uniform int _MaxParticlesCount;
uniform int _PrioritizeNewParticles;

// Move variables
// x = Gravity, y = _FloorHeight, z = MaxSpeed, w = ?
uniform float4 _SimulationBase;
// xyz = Wind Direction
uniform float4 _Wind;
uniform Texture2D<float3> _NoiseMap;
SamplerState sampler_NoiseMap;
// XY = Tilling, Z = Strength, W = ?
uniform float4 _NoiseMap_ST;
uniform float4 _TargetPosition;
// XYZ = Position, W = TargetAttractionForce
uniform float4 _ParticlesTarget;

uniform RWBuffer<int> _IndirectArgs; // buffer union args, simulation args

#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)

/** 
Set the threads value for dispatch indirect
**/
[numthreads(1,1,1)]
void CSSetIndirectArgs (uint3 id : SV_DispatchThreadID)
{
    int argsUnion = ceil(float(_ParticlesDrawArgs[4]) / WARP_SIZE);
    _IndirectArgs[0] = argsUnion;
    
    float maxParticlesToSimulate = min(_ParticlesCounter + _ParticlesDrawArgs[4], _MaxParticlesCount);
    int argsSimulation = ceil(maxParticlesToSimulate / WARP_SIZE);
    _IndirectArgs[3] = argsSimulation;
}

[numthreads(1,1,1)]
void CSClearIndirectDrawArgs (uint3 id : SV_DispatchThreadID)
{
    // Set the previous counter with actual buffer size
    _ParticlesDrawArgs[4] = _ParticlesDrawArgs[1];
    _ParticlesDrawArgs[1] = 0;
}

inline int GetNegativeSplineIndex(int splineIndex)
{
    return -splineIndex - 1;
}

/**
Here we handle the movements of the particles
**/
[numthreads(WARP_SIZE,1,1)]
void CSParticlesSimulation (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x;
    if (particleIndex > _ParticlesCounter)
        return;
    
    ParticleDatas datas = _ParticlesDatasBuffer[particleIndex]; 
    ParticlesConfig config = _ParticlesConfigs[datas.indexConfig];
    

    if (config.flagsFeature & FLAG_KILL_ALL)
    {
        datas.duration = -1;
        _ParticlesDatasBuffer[particleIndex] = datas;
        return;
    }

    float timeLived = _Time_SSFX.x - datas.timeApparition;
    float lifeProgress = timeLived / datas.duration;
    
    if (config.flagsFeature & FLAG_TARGET)
    {
        if (datas.startTargetDistance < 0)
            datas.startTargetDistance = length(datas.worldPosition - config.targetDatas.xyz);
        if (config.flagsFeature & FLAG_LIFETIME_IS_TARGET_DISTANCE)
            lifeProgress = 1.0 - min(1, length(datas.worldPosition - config.targetDatas.xyz) / datas.startTargetDistance);
    }
   
    if (config.flagsFeature & FLAG_SIZE_OVER_LIFETIME)
        datas.size = datas.startSize * GetCurveValue(config.grad_sizeOverLifetime, lifeProgress);

    if (config.flagsFeature & FLAG_COLOR_OVER_LIFETIME)
    {
        if (config.flagsFeature & FLAG_ALPHA_OVER_LIFETIME)
        {
            float lerpProgress = GetCurveValue(config.grad_alphaOverLifetime, lifeProgress);
            float3 color = GetCurveColor(config.grad_colorOverLifetime, lifeProgress);
            datas.color.rgb = lerp(datas.startColor, color, lerpProgress);
        }
        else 
            datas.color.rgb = GetCurveColor(config.grad_colorOverLifetime, lifeProgress);
    }

     float lenSpeed = length(datas.startSpeed);
    // Speed over lifetime
    if (config.flagsFeature & FLAG_SPEED_OVER_LIFETIME)
    {
        datas.speed = normalize(datas.speed) * datas.startSpeed * GetCurveValue(config.grad_speedOverLifetime, lifeProgress);
        lenSpeed = length(datas.speed);
    }
   

    float3 directionToTarget = datas.speed;
    float targetAttraction = 10.0;

    float3 targetForcedPoint;
    

    // Move to spline point
    if (config.flagsFeature & FLAG_FOLLOW_SPLINE)
    {
        // Search if we are in spline bound
        if (datas.splineFollowIndex < 0)
        {
            //datas.color.rgb = float3(1, 1, 0);
            int closestSplineIndex = -1;
            int closestPointIndex = -1;
            float shortestDist = 999.0;
            float dist;
            for (int i = 0; i < _SplineCount; i++)
            {
                // Negative index is used to remember previous spline used and be sure to not follow it again.
                if (GetNegativeSplineIndex(i) == datas.splineFollowIndex)
                    continue;
                // Expensive search. Could be optimized for a fast realtime usage.
                SplineInfos spline = _SplinesInfos[i];
                if (datas.worldPosition.x > spline.borderMin.x && datas.worldPosition.x < spline.borderMax.x
                    && datas.worldPosition.y > spline.borderMin.y && datas.worldPosition.y < spline.borderMax.y
                    && datas.worldPosition.z > spline.borderMin.z && datas.worldPosition.z < spline.borderMax.z)
                    {
                        //datas.color.rgb = float3(1, 0, 0);
                        
                        for (int j = 0; j < spline.positionsCount; j++)
                        {
                            float4 splineStep = _SplinesPositions[spline.indexStartPositions + j];
                            dist = length(datas.worldPosition.xyz - splineStep.xyz);
                            if (dist < shortestDist)
                            {
                                shortestDist = dist;
                                closestPointIndex = spline.indexStartPositions + j;
                                closestSplineIndex = i;
                            }
                        }
                    }
            }
            
            if (closestSplineIndex != -1)
            {
                datas.splineFollowIndex = closestSplineIndex;
                datas.splineCurrentStep = closestPointIndex;
            }
        }
        
        // Positive index means this particle follow a spline.
        if (datas.splineFollowIndex >= 0)
        {
            float4 splinePoint = _SplinesPositions[datas.splineCurrentStep];
            float3 directionMove = _SplinesPositions[datas.splineCurrentStep].xyz - _SplinesPositions[datas.splineCurrentStep - 1].xyz;
            float3 normal = cross(float3(0, 1, 0), directionMove);
            float3 normal1 = cross(float3(1, 0, 0), directionMove);
            normal = normalize(length(normal) > length(normal1) ? normal : normal1);
            // Rotate normal 
            normal = normal * cos(datas.splineAngleOffset) + cross(directionMove, normal) * sin(datas.splineAngleOffset)
                + (1 - cos(datas.splineAngleOffset)) * dot(directionMove, normal) * directionMove;
            normal = normalize(normal);

            splinePoint.xyz += datas.splineOffset * splinePoint.w * normal;
            
            // Set speed
            float3 dirToPoint = splinePoint.xyz - datas.worldPosition.xyz;
            directionToTarget = dirToPoint;
            float3 speedToTarget = normalize(directionToTarget) * lenSpeed;
            datas.speed = normalize(lerp(datas.speed, speedToTarget, targetAttraction * _Time_SSFX.y)) * lenSpeed;
            float currentDistance = length(splinePoint.xyz - datas.worldPosition.xyz);
            float nextDistance = length(splinePoint.xyz - (datas.worldPosition.xyz + datas.speed));
            // Reach step, target the next one.
            if (currentDistance < nextDistance)
            {
                datas.speed = directionToTarget * lenSpeed;
                SplineInfos info = _SplinesInfos[datas.splineFollowIndex];
                if (datas.splineCurrentStep + 1 < info.indexStartPositions + info.positionsCount)
                    datas.splineCurrentStep += 1;
                else 
                {
                    datas.splineFollowIndex = GetNegativeSplineIndex(datas.splineFollowIndex);
                }
            }
            
            // Vector lerp to smoothly attract particles in spline
            //lerp(directionMove, dirToPoint, length(dirToPoint) / 1.2);

        }
    }

    // Move to target
    if (config.flagsFeature & FLAG_TARGET)
    {
        float3 directionToTransformTarget = config.targetDatas.xyz - datas.worldPosition.xyz;

        // Follow target only if not already following a spline
        if ((!config.flagsFeature & FLAG_FOLLOW_SPLINE || datas.splineFollowIndex < 0))
        {
            directionToTarget = directionToTransformTarget;
        }

        float particleDistToTarget = length(directionToTransformTarget);
        float targetDeathRadius;
        Unpack2Float32(config.targetDatas.w, 100.0, 20.0, targetAttraction, targetDeathRadius);
        if (config.flagsFeature & FLAG_TARGET_DIE_ON_REACH && particleDistToTarget < targetDeathRadius)
            datas.duration = -1;
        
        // Set speed
        float3 speedToTarget = normalize(directionToTarget) * lenSpeed;
        datas.speed = normalize(lerp(datas.speed, speedToTarget, targetAttraction * _Time_SSFX.y)) * lenSpeed;
        float currentDistance = length(config.targetDatas.xyz - datas.worldPosition.xyz);
        float nextDistance = length(config.targetDatas.xyz - (datas.worldPosition.xyz + datas.speed));
        if (currentDistance < nextDistance)
        {
            datas.speed = directionToTarget;
        }
    }

    datas.worldPosition += float4(datas.speed * _Time_SSFX.y, 0);
    _ParticlesDatasBuffer[particleIndex] = datas;
}

/**
The goal here is to add the previous still alive particles
to the buffer of new particles
**/
[numthreads(WARP_SIZE,1,1)]
void CSBufferUnion (uint id : SV_DispatchThreadID)
{
    int bufferIndex = id.x;
    int previousBufferSize = _ParticlesDrawArgs[4];

    if (bufferIndex > previousBufferSize)
        return;
    
    if (!_PrioritizeNewParticles)
        bufferIndex = previousBufferSize - id.x;
    
    if (_ParticlesCounter >= _MaxParticlesCount)
        return;

    ParticleDatas particle = _PreviousParticlesDatasBuffer[bufferIndex];
    float timeLived = _Time_SSFX.x - particle.timeApparition;
    if (timeLived < particle.duration && particle.duration > 0) 
    {
        // Check if the particle is still alive
        int indexNewBuffer;
        InterlockedAdd(_ParticlesCounter, 1, indexNewBuffer);
        if (indexNewBuffer >= _MaxParticlesCount)
        {
            if (_PrioritizeNewParticles)
                return;
            else 
            {
                // Replace new particles by older at the beginning of the buffer
                // _ParticlesDrawArgs[6] is the index to use if buffer is full
                InterlockedAdd(_ParticlesDrawArgs[6], 1, indexNewBuffer);
            }
        }
        _ParticlesDatasBuffer[indexNewBuffer] = particle;
    }
}