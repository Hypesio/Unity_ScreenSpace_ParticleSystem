// Here we will handle the particles 
// Their position, collisions, etc...
#define WARP_SIZE 256

#pragma kernel CSSetIndirectArgs
#pragma kernel CSParticlesSimulation
#pragma kernel CSBufferUnion
#pragma kernel CSClearIndirectDrawArgs

#include "ParticlesCommons.cginc"
#include "SSFXUtils.cginc"

// 0 - VertexCount
// 1 - InstanceCount 
// 2 - StartVertexCount a
// 3 - StartInstanceLocation 
// 4 - PreviousInstanceCount
// 5 - FrameNumber
// 6 - Index if buffer full
uniform RWBuffer<int> _ParticlesDrawArgs;
#define _ParticlesCounter _ParticlesDrawArgs[1]

uniform RWStructuredBuffer<ParticleDatas> _ParticlesDatasBuffer;
uniform StructuredBuffer<ParticleDatas> _PreviousParticlesDatasBuffer;
uniform StructuredBuffer<ParticlesConfig> _ParticlesConfigs;
uniform Buffer<float4> _SplinesPositions;
uniform StructuredBuffer<SplineInfos> _SplinesInfos;
uniform int _SplineCount;
uniform int _MaxParticlesCount;
uniform int _PrioritizeNewParticles;

// Move variables
// x = Gravity, y = _FloorHeight, z = MaxSpeed, w = ?
uniform float4 _SimulationBase;
// xyz = Wind Direction
uniform float4 _Wind;
uniform Texture2D<float3> _NoiseMap;
SamplerState sampler_NoiseMap;
// XY = Tilling, Z = Strength, W = ?
uniform float4 _NoiseMap_ST;
uniform float4 _TargetPosition;
// XYZ = Position, W = TargetAttractionForce
uniform float4 _ParticlesTarget;

uniform RWBuffer<int> _IndirectArgs; // buffer union args, simulation args

#define TRANSFORM_TEX(tex,name) (tex.xy * name##_ST.xy + name##_ST.zw)

/** 
Set the threads value for dispatch indirect
**/
[numthreads(1,1,1)]
void CSSetIndirectArgs (uint3 id : SV_DispatchThreadID)
{
    int argsUnion = ceil(float(_ParticlesDrawArgs[4]) / WARP_SIZE);
    _IndirectArgs[0] = argsUnion;
    
    float maxParticlesToSimulate = min(_ParticlesCounter + _ParticlesDrawArgs[4], _MaxParticlesCount);
    int argsSimulation = ceil(maxParticlesToSimulate / WARP_SIZE);
    _IndirectArgs[3] = argsSimulation;
}

[numthreads(1,1,1)]
void CSClearIndirectDrawArgs (uint3 id : SV_DispatchThreadID)
{
    // Set the previous counter with actual buffer size
    _ParticlesDrawArgs[4] = _ParticlesDrawArgs[1];
    _ParticlesDrawArgs[1] = 0;
}

/**
Here we handle the movements of the particles
**/
[numthreads(WARP_SIZE,1,1)]
void CSParticlesSimulation (uint3 id : SV_DispatchThreadID)
{
    int particleIndex = id.x;
    if (particleIndex > _ParticlesCounter)
        return;
    
    ParticleDatas datas = _ParticlesDatasBuffer[particleIndex]; 
    ParticlesConfig config = _ParticlesConfigs[datas.indexConfig];

    if (config.flagsFeature & FLAG_KILL_ALL)
    {
        datas.duration = -1;
        _ParticlesDatasBuffer[particleIndex] = datas;
        return;
    }
    
    float timeLived = _Time_SSFX.x - datas.timeApparition;
    float lifeProgress = timeLived / datas.duration;

    if (config.flagsFeature & FLAG_SIZE_OVER_LIFETIME)
        datas.size = datas.startSize * GetCurveValue(config.grad_sizeOverLifetime, lifeProgress);

    if (config.flagsFeature & FLAG_COLOR_OVER_LIFETIME)
    {
        if (config.flagsFeature & FLAG_ALPHA_OVER_LIFETIME)
        {
            float lerpProgress = GetCurveValue(config.grad_alphaOverLifetime, lifeProgress);
            float3 color = GetCurveColor(config.grad_colorOverLifetime, lifeProgress);
            datas.color.rgb = lerp(datas.startColor, color, lerpProgress);
        }
        else 
            datas.color.rgb = GetCurveColor(config.grad_colorOverLifetime, lifeProgress);
    }

    // Size over lifetime
    if (config.flagsFeature & FLAG_SPEED_OVER_LIFETIME)
        datas.speed = normalize(datas.speed) * datas.startSpeed * GetCurveValue(config.grad_speedOverLifetime, lifeProgress);
    float lenSpeed = length(datas.speed);

    float3 directionToTarget;
    float targetAttraction = 10.0;
    // Move to spline point
    if (config.flagsFeature & FLAG_FOLLOW_SPLINE)
    {
        // Search if we are in spline bound
        if (datas.splineFollowIndex == -1)
        {
            datas.color.rgb = float3(1, 1, 0);
            int closestSplineIndex = -1;
            int closestPointIndex = -1;
            float shortestDist = 999.0;
            float dist;
            for (int i = 0; i < _SplineCount; i++)
            {
                // Expensive search. Could be optimized a fast realtime usage.
                SplineInfos spline = _SplinesInfos[i];
                if (datas.worldPosition.x > spline.borderMin.x && datas.worldPosition.x < spline.borderMax.x
                    && datas.worldPosition.y > spline.borderMin.y && datas.worldPosition.y < spline.borderMax.y
                    && datas.worldPosition.z > spline.borderMin.z && datas.worldPosition.z < spline.borderMax.z)
                    {
                        datas.color.rgb = float3(1, 0, 0);
                        
                        for (int j = 0; j < spline.positionsCount; j++)
                        {
                            float4 splineStep = _SplinesPositions[spline.indexStartPositions + j];
                            dist = length(datas.worldPosition - splineStep.xyz);
                            if (dist < shortestDist)
                            {
                                shortestDist = dist;
                                closestPointIndex = spline.indexStartPositions + j;
                                closestSplineIndex = i;
                            }
                        }
                    }
                    
                if (closestSplineIndex != -1)
                {
                    datas.splineFollowIndex = closestSplineIndex;
                    datas.splineCurrentStep = closestPointIndex;
                }
            }
        }
        
        if (datas.splineFollowIndex != -1)
        {
            float4 splinePoint = _SplinesPositions[datas.splineCurrentStep];
             float3 directionMove = _SplinesPositions[datas.splineCurrentStep + 1] - _SplinesPositions[datas.splineCurrentStep];
            if (dot(splinePoint - datas.worldPosition, directionMove) < 0)
            {
                SplineInfos info = _SplinesInfos[datas.splineFollowIndex];
                if (datas.splineCurrentStep + 1 < info.indexStartPositions + info.positionsCount)
                    datas.splineCurrentStep += 1;
            }

            float3 dirToPoint = _SplinesPositions[datas.splineCurrentStep] - datas.worldPosition.xyz;
            directionToTarget = lerp(directionMove, dirToPoint, length(dirToPoint) / 2.2f);
        }
    }

    // Move to target
    if (config.flagsFeature & FLAG_TARGET && 
        (!config.flagsFeature & FLAG_FOLLOW_SPLINE || datas.splineFollowIndex == -1))
        // Follow target only if not already following a spline
    {
        directionToTarget = config.targetDatas.xyz - datas.worldPosition.xyz;
        float particleDistToTarget = length(directionToTarget);
        float targetDeathRadius;
        Unpack2Float32(config.targetDatas.w, 100.0f, 20.0f, targetAttraction, targetDeathRadius);
        if (config.flagsFeature & FLAG_TARGET_DIE_ON_REACH && particleDistToTarget < targetDeathRadius)
            datas.duration = -1;
    }

    if (config.flagsFeature & FLAG_TARGET || (config.flagsFeature & FLAG_FOLLOW_SPLINE && datas.splineFollowIndex != -1)){
        float3 speedToTarget = normalize(directionToTarget) * lenSpeed;
        datas.speed = normalize(lerp(datas.speed, speedToTarget, targetAttraction * _Time_SSFX.y)) * lenSpeed;
    }

    datas.worldPosition += float4(datas.speed * _Time_SSFX.y, 0);
    _ParticlesDatasBuffer[particleIndex] = datas;
}

/**
The goal here is to add the previous still alive particles
to the buffer of new particles
**/
[numthreads(WARP_SIZE,1,1)]
void CSBufferUnion (uint id : SV_DispatchThreadID)
{
    int bufferIndex = id.x;
    int previousBufferSize = _ParticlesDrawArgs[4];

    if (bufferIndex > previousBufferSize)
        return;
    
    if (!_PrioritizeNewParticles)
        bufferIndex = previousBufferSize - id.x;
    
    if (_ParticlesCounter >= _MaxParticlesCount)
        return;

    ParticleDatas particle = _PreviousParticlesDatasBuffer[bufferIndex];
    float timeLived = _Time_SSFX.x - particle.timeApparition;
    if (timeLived < particle.duration && particle.duration > 0) 
    {
        // Check if the particle is still alive
        int indexNewBuffer;
        InterlockedAdd(_ParticlesCounter, 1, indexNewBuffer);
        if (indexNewBuffer >= _MaxParticlesCount)
        {
            if (_PrioritizeNewParticles)
                return;
            else 
            {
                // Replace new particles by older at the beginning of the buffer
                // _ParticlesDrawArgs[6] is the index to use if buffer is full
                InterlockedAdd(_ParticlesDrawArgs[6], 1, indexNewBuffer);
            }
        }
        _ParticlesDatasBuffer[indexNewBuffer] = particle;
    }
}